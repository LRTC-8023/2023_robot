package frc.robot.autonomous;

import com.ctre.phoenix.motorcontrol.ControlMode;

import frc.robot.Components;

public class twoCubeBalance extends AutonomousBase {

    public twoCubeBalance(Components components) {
        super(components);
    }

    private enum State {
        firstDeposit,
        starting,
        ascending,
        onFlat,
        descending,
        lowerArm,
        driveUntilCube,
        raiseArm,
        comeBackToTarget,
        startBalancing,
        balancing,
    }

    private State state;
    // private Double position;
    private final double encoder2inches = 1 / 8.46; // Unit Conversion

    private Double targetPosition;


    @Override
    public void init() {
        super.init();
        state = State.starting;
    }

    @Override
    public void periodic() {
        super.periodic();
        boolean frontLimitSensor = components.frontLimitSensor.get();
        boolean backLimitSensor = components.backLimitSensor.get();
        boolean cubeSensor = components.cubeSensor.get();

        // vAngleTest is for YComplementaryAngle and I use it for autos that I am
        // testing,
        // I know I could just use vAngle that is in the kDriveForwardAndBalance but
        // I just don't want to miss around with it.
        double vAngleTest = components.gyro.getYComplementaryAngle();
        double currentPosition = components.encoder.getPosition();

        // rio is mounted backward
        vAngleTest = vAngleTest * -1;

        // if (this.currentTime - this.startTime < 1) {
        //     components.rollerMotor.set(this.targetRollerSpeed);
        // } else {
        //     components.rollerMotor.set(0);
        // }

        switch (state) {
            case firstDeposit:
                if(cubeSensor){
                    components.rollerMotor.set(0.5);
                }else{
                    state = State.starting;
                    System.out.println("State: " + state);
                }
            break;
            case starting:
                if (vAngleTest > 5) {
                    state = State.ascending;
                    System.out.println("State: " + state);
                }else{
                    components.drive.tankDrive(0.55, 0.55);
                }
                break;

            case ascending:
                if (vAngleTest < 0) {
                    state = State.onFlat;
                    System.out.println("State: " + state);
                }else{
                    components.drive.tankDrive(0.55, 0.55);
                }
                break;

            case onFlat:
                if (Math.abs(vAngleTest) > 5) {
                    state = State.descending;
                    System.out.println("State: " + state);
                }else{
                components.drive.tankDrive(0.2, 0.2);
                }
                break;

            case descending:
                if (Math.abs(vAngleTest) < 2) {
                    // position = Math.abs(currentPosition);
                    components.encoder.setPosition(0);
                    targetPosition = Math.abs(currentPosition) * encoder2inches;
                    state = State.lowerArm;
                    System.out.println("State: " + state);
                }else{
                components.drive.tankDrive(0.2, 0.2);
                }
                break;

            case lowerArm:
                if(frontLimitSensor == false){
                    components.raisingMotor.set(0.6);
                }else{
                components.raisingMotor.set(0);
                state = State.driveUntilCube;
                System.out.println("State: " + state);}
                break;
            case driveUntilCube:
                if((Math.abs(components.encoder.getPosition()) * encoder2inches) < 100 && cubeSensor == false){
                    components.drive.tankDrive(0.6,0.6);
                    components.rollerMotor.set(-0.7);
                    System.out.println("State: " + state);
                }else{
                    components.drive.tankDrive(0,0);
                    components.rollerMotor.set(0);
                    state = State.raiseArm;
                }
                break;
            
            case raiseArm:
                if(backLimitSensor == false){
                    components.raisingMotor.set(-0.6);
                    System.out.println("State: " + state);
                }else{
                    state = State.comeBackToTarget;
                }
            
            case comeBackToTarget:
                if(Math.abs(currentPosition) * encoder2inches > targetPosition -15){
                    components.drive.tankDrive(-0.6, -0.6);
                    System.out.println("State: " + state);
                }else{
                    state = State.balancing;
                }
                break;

            case balancing:
                if (vAngleTest > 2) {
                    components.drive.tankDrive(0.3, 0.3);
                    System.out.println("State: " + state);
                }
                if (vAngleTest < -2) {
                    components.drive.tankDrive(-0.3, -0.3);
                }
                break;

            default:
                break;
        }
    }
}